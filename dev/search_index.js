var documenterSearchIndex = {"docs":
[{"location":"#Timestamps64.jl","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"(Image: License: MIT) (Image: Maintenance) (Image: Stable Documentation)","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"This package provides an efficient Timestamp64 datetime type with nanosecond precision. It is a wrapper around a single Int64 value (8 bytes) that represents the number of nanoseconds since the UNIX epoch. Benchmarks show that common date/time operations are as fast as Julia's built-in DateTime type, or even significantly faster in some cases (see below).","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Timestamp64 can store values ranging from 1970-01-01T00:00:00.000000000 to 2262-04-11 23:47:16.854775807, which should be sufficient for most applications.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"This package works with Julia's built-in Dates module, providing methods to convert between Timestamp64 and DateTime, Date, and Time types. Furthermore, the common accessor functions for year, month, day, hour, minute, second, millisecond, microsecond, and nanosecond, among others, are provided.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Every function is unit-tested to ensure correctness, usually against the corresponding Dates function.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"note: Timestamps64 precision vs. Dates.DateTime\nThe default precision/unit of the difference of two Timestamp64 objects is Nanosecond, while the default precision/unit of the difference of two DateTime objects is Millisecond.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"note: Timestamps64 time rounding vs. Dates.DateTime\nDue to a different origin epoch (1970-01-01T00:00:00.000000000 in Timestamp64 vs. 0000-01-01T00:00:00 in DateTime), the rounding of Timestamp64 with time periods smaller than Day(1) is not identical to the rounding of DateTime. This implementation corresponds to C++'s chrono rounding behavior.","category":"page"},{"location":"#Supported-platforms","page":"Timestamps64.jl","title":"Supported platforms","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"This package is supported on the following platforms (64-bit only):","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Linux\nmacOS Sierra 10.12 and later (needs clock_gettime support)\nWindows 10 / Windows Server 2016 and later (requires GetSystemTimePreciseAsFileTime)","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"note: Windows clock resolution\nWindows exposes the wall-clock in 100-nanosecond ticks via GetSystemTimePreciseAsFileTime, so while Timestamp64 reports nanosecond values, the effective resolution on Windows remains 100 ns (sometimes coarser depending on hardware).","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Examples of not supported platforms:","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Any 32-bit system\nWindows versions earlier than 10 (e.g., Windows 8.1)\nOlder macOS versions before 10.12","category":"page"},{"location":"#Background","page":"Timestamps64.jl","title":"Background","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The reason this package was created is that the built-in Dates.DateTime type in Julia is not able to represent nanosecond precision. The Dates.DateTime type has millisecond precision, which is insufficient for some specialized applications.","category":"page"},{"location":"#API-documentation","page":"Timestamps64.jl","title":"API documentation","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using Timestamps64\nusing Dates\n\n# Create a timestamp\nts = Timestamp64(2021, 12, 31, 23, 58, 59, nanoseconds=123456789)\n\n# Current timestamp in UTC with nanosecond precision\nnow(Timestamp64)\n\n# Current timestamp in UTC with nanosecond precision (explicit)\nnow(Timestamp64, UTC)\n\n# Today's timestamp in UTC at midnight\ntoday(Timestamp64)\n\n# Today's timestamp in UTC at midnight (explicit)\ntoday(Timestamp64, UTC)\n\n# Convert from various ISO 8601 string formats\nTimestamp64(\"2021-01-01T00:00:01\")\nTimestamp64(\"2021-01-01T00:00:01Z\")\nTimestamp64(\"2021-01-01T00:00:00.001\") # 1 millisecond\nTimestamp64(\"2021-01-01T00:00:00.001Z\") # 1 millisecond\nTimestamp64(\"2021-01-01T00:00:00.000001\") # 1 microsecond\nTimestamp64(\"2021-01-01T00:00:00.000001Z\") # 1 microsecond\nTimestamp64(\"2021-01-01T00:00:00.000000001\") # 1 nanosecond\nTimestamp64(\"2021-01-01T00:00:00.000000001Z\") # 1 nanosecond\n\n# Base.parse is also supported (only ISO 8601 / RFC 3339 up to nanoseconds formats)\nparse(Timestamp64, \"2021-01-01T00:00:00.000000001Z\", Dates.ISODateTimeFormat)\nparse(Timestamp64, \"2021-01-01T00:00:00\")\nparse(Timestamp64, \"2021-01-01T00:00:00.001\")\nparse(Timestamp64, \"2021-01-01T00:00:00.000000001Z\", ISOTimestamp64Format)\n\n\n## Dates conversion\n\n# Convert to DateTime, which only has millisecond precision\nDateTime(ts)\nconvert(DateTime, ts)\n\n# Convert to Date\nDate(ts)\nconvert(Date, ts)\n\n# Convert to Time\nTime(ts)\nconvert(Time, ts)\n\n# Create from DateTime (only with millisecond precision)\ndt = now()\nTimestamp64(dt)\n\n# Create from Date and Time (nanosecond precision)\nTimestamp64(Date(2021, 12, 31), Time(23, 58, 59, 123, 456, 789))\n\n\n## Accessor functions\nyear(ts)\nmonth(ts)\nday(ts)\nhour(ts)\nminute(ts)\nsecond(ts)\nnanosecond(ts)\nmillisecond(ts)\nmicrosecond(ts)\nnanosecond(ts)\nyearmonth(ts)\nyearmonthday(ts)\nmonthday(ts)\nmonthname(ts)\nisleapyear(ts)\ndayofweek(ts)\n\n\n## String conversions\n\n# Convert to string (ISO 8601 default)\nstring(ts)\n\n# Convert to ISO 8601 string explicitly\niso8601(ts)\n\n# Print string (ISO 8601 default)\nprintln(ts)\n\n# Dates.format is also supported\nDates.format(ts, Dates.ISODateTimeFormat)\nDates.format(ts, ISOTimestamp64Format)\n\n\n## Arithmetic\n\n# Add period\nts2 = ts + Millisecond(100)\nts2 - ts\n\n# Subtract period\nts2 = ts - Microsecond(1)\nts2 - ts\n\n# Difference of two timestamps\nts1 = Timestamp64(2022, 12, 31, 23, 58, 59)\nts2 = Timestamp64(2023, 1, 1, 23, 58, 59)\nts2 - ts1\nDay(ts2 - ts1)\n\n\n## Numeric operations\n\n# Type constants\neps(Timestamp64)\nzero(Timestamp64)\niszero(Timestamp64(0))\ntypemin(Timestamp64)\ntypemax(Timestamp64)\n\n# Compare timestamps\nts1 < ts2\nts1 > ts2\nts1 == ts2\n\n# Automatic type promotion\nTimestamp64(2020, 1, 1) < DateTime(2020, 1, 2)\nTimestamp64(2020, 1, 1) < Date(2020, 1, 2)\n\n\n## Rounding\n\n# Floor to nearest period value\nfloor(ts, Nanosecond(5))\nfloor(ts, Microsecond(5))\nfloor(ts, Millisecond(5))\nfloor(ts, Second(5))\nfloor(ts, Minute(5))\nfloor(ts, Hour(5))\nfloor(ts, Day(5))\nfloor(ts, Month(5))\nfloor(ts, Quarter(5))\nfloor(ts, Year(5))\n\n# Ceil to nearest period\nceil(ts, Nanosecond(5))\nceil(ts, Microsecond(5))\nceil(ts, Millisecond(5))\nceil(ts, Second(5))\nceil(ts, Minute(5))\nceil(ts, Hour(5))\nceil(ts, Day(5))\nceil(ts, Month(5))\nceil(ts, Quarter(5))\nceil(ts, Year(5))\n\n# Round to nearest period\nround(ts, Nanosecond(5))\nround(ts, Microsecond(5))\nround(ts, Millisecond(5))\nround(ts, Second(5))\nround(ts, Minute(5))\nround(ts, Hour(5))\nround(ts, Day(5))\nround(ts, Month(5))\nround(ts, Quarter(5))\nround(ts, Year(5))\n\n\n## Ranges\n\n# Create a range of timestamps using arbitrary periods\ncollect(Timestamp64(2020, 1, 1):Day(1):Timestamp64(2020, 1, 10))\ncollect(Timestamp64(2020, 1, 1):Week(1):Timestamp64(2020, 1, 31))\ncollect(Timestamp64(2020, 1, 1):Month(1):Timestamp64(2020, 12, 31))\ncollect(Timestamp64(2020, 1, 1):Quarter(1):Timestamp64(2020, 12, 31))\ncollect(Timestamp64(2020, 1, 1):Year(1):Timestamp64(2022, 1, 1))\n\n\n## UNIX timestamp conversions\n\n# create from UNIX timestamp in nanoseconds\nTimestamp64(1704412800000000000)\n\n# get UNIX timestamp in nanoseconds\nDates.value(ts)\nunix_nanos(ts)\nunix(Nanosecond, ts)\n\n# get UNIX timestamp in microseconds\nunix_micros(ts)\nunix(Microsecond, ts)\n\n# get UNIX timestamp in milliseconds\nunix_millis(ts)\nunix(Millisecond, ts)\n\n# get UNIX timestamp in seconds\nunix_secs(ts)\nunix(Second, ts)","category":"page"},{"location":"#Performance","page":"Timestamps64.jl","title":"Performance","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The Timestamp64 implementation is very efficient and has a small memory footprint with only 8 bytes. Common operations such as creating, parsing, converting, and formatting timestamps have been optimized and are as fast as Julia's built-in DateTime implementation, or even faster.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The following benchmark results have been obtained on an Intel(R) Core(TM) i9-12900K CPU on Ubuntu 22.04 using Julia 1.10.4.","category":"page"},{"location":"#Get-object-with-current-date/time-in-UTC","page":"Timestamps64.jl","title":"Get object with current date/time in UTC","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\n@btime now(Timestamp64, UTC);\n@btime now(UTC);","category":"page"},{"location":"#Result","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime now(Timestamp64, UTC);\n  11.392 ns (0 allocations: 0 bytes)\n\njulia> @btime now(UTC);\n  22.015 ns (0 allocations: 0 bytes)","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The Timestamp64 type is almost 2 times faster at getting the current UTC time compared to Julia's built-in DateTime type!","category":"page"},{"location":"#Construction-from-date-parts","page":"Timestamps64.jl","title":"Construction from date parts","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\nconst year = 2021;\n\n@btime Timestamp64($year, 1, 1, 0, 0, 1, 123*1_000_000); # last parameter in nanoseconds!\n@btime DateTime($year, 1, 1, 0, 0, 1, 123);","category":"page"},{"location":"#Result-2","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The Timestamp64 type is 1.7 times faster at constructing a datetime object from its parts compared to Julia's built-in DateTime type!","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime Timestamp64($year, 1, 1, 0, 0, 1, 123);\n  3.364 ns (0 allocations: 0 bytes)\n\njulia> @btime DateTime($year, 1, 1, 0, 0, 1, 123);\n  5.644 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#Parsing-ISO-8601-strings","page":"Timestamps64.jl","title":"Parsing ISO 8601 strings","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\n@btime Timestamp64(\"2021-01-01T00:00:01\");\n@btime DateTime(\"2021-01-01T00:00:01\");\n\n@btime Timestamp64(\"2021-01-01T00:00:01.001\");\n@btime DateTime(\"2021-01-01T00:00:01.001\");","category":"page"},{"location":"#Result-3","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The Timestamp64 type is almost 1.5 times faster at parsing ISO 8601 strings compared to Julia's built-in DateTime type!","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime Timestamp64(\"2021-01-01T00:00:01\");\n  16.175 ns (0 allocations: 0 bytes)\n\njulia> @btime DateTime(\"2021-01-01T00:00:01\");\n  23.312 ns (0 allocations: 0 bytes)\n\njulia> @btime Timestamp64(\"2021-01-01T00:00:01.001\");\n  19.271 ns (0 allocations: 0 bytes)\n\njulia> @btime DateTime(\"2021-01-01T00:00:01.001\");\n  27.942 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#Format-to-ISO-8601-strings","page":"Timestamps64.jl","title":"Format to ISO 8601 strings","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\nts = Timestamp64(2021, 1, 1, 0, 0, 1) + Millisecond(123)\ndt = DateTime(2021, 1, 1, 0, 0, 1) + Millisecond(123)\n\n# ISO 8601 string formatting\n@btime Dates.format($ts, ISOTimestamp64Format);\n@btime Dates.format($dt, Dates.ISODateTimeFormat);","category":"page"},{"location":"#Result-4","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The Timestamp64 type is more than 6 times faster at formatting to a ISO 8601 string compared to Julia's built-in DateTime type, and with fewer allocations!","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime Dates.format($ts, ISOTimestamp64Format);\n  46.626 ns (4 allocations: 200 bytes)\n\njulia> @btime Dates.format($dt, Dates.ISODateTimeFormat);\n  286.392 ns (19 allocations: 928 bytes)","category":"page"},{"location":"#Calculate-difference","page":"Timestamps64.jl","title":"Calculate difference","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Note that the Timestamp64 type has nanosecond precision, while the DateTime type has millisecond precision, so the return type is correspondingly Nanosecond for Timestamp64 and Millisecond for DateTime.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\nts1 = Timestamp64(2021, 1, 1, 0, 0, 1);\nts2 = Timestamp64(2021, 1, 1, 0, 0, 2);\n\ndt1 = DateTime(2021, 1, 1, 0, 0, 1);\ndt2 = DateTime(2021, 1, 1, 0, 0, 2);\n\n@btime $ts2 - $ts1;\n@btime $dt2 - $dt1;","category":"page"},{"location":"#Result-5","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Identical performance for both Timestamp64 and DateTime types.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime $ts2 - $ts1;\n  1.356 ns (0 allocations: 0 bytes)\n\njulia> @btime $dt2 - $dt1;\n  1.358 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#Access-UNIX-timestamp-in-seconds","page":"Timestamps64.jl","title":"Access UNIX timestamp in seconds","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\nts = Timestamp64(2021, 1, 1, 0, 0, 1) + Millisecond(123);\ndt = DateTime(2021, 1, 1, 0, 0, 1) + Millisecond(123);\n\n@btime unix_secs($ts);\n@btime trunc(Int64, datetime2unix($dt));","category":"page"},{"location":"#Result-6","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Due to the internal representation of the Timestamp64 value as UNIX timestamp in nanoseconds, the conversion to a UNIX timestamp in seconds is trivial and therefore 2.3 times faster compared to Julia's built-in DateTime type using the datetime2unix function.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime unix_secs($ts);\n  1.571 ns (0 allocations: 0 bytes)\n\njulia> @btime trunc(Int64, datetime2unix($dt));\n  3.654 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#Access-UNIX-timestamp-in-milliseconds","page":"Timestamps64.jl","title":"Access UNIX timestamp in milliseconds","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\nts = Timestamp64(2021, 1, 1, 0, 0, 1) + Millisecond(123);\ndt = DateTime(2021, 1, 1, 0, 0, 1) + Millisecond(123);\n\n@btime unix_millis($ts);\n@btime trunc(Int64, datetime2unix($dt)*1000);","category":"page"},{"location":"#Result-7","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Due to the internal representation of the Timestamp64 value as UNIX timestamp in nanoseconds, the conversion to a UNIX timestamp in seconds is trivial and therefore 2.6 times faster compared to Julia's built-in DateTime type using the datetime2unix function.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime unix_millis($ts);\n  1.729 ns (0 allocations: 0 bytes)\n\njulia> @btime trunc(Int64, datetime2unix($dt)*1000);\n  4.420 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#Create-object-from-UNIX-timestamp-in-milliseconds","page":"Timestamps64.jl","title":"Create object from UNIX timestamp in milliseconds","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\nunix_millis = 1609459201000; # 2021-01-01T00:00:01.000000000\n\n@btime Timestamp64($unix_millis * 1_000_000);\n@btime unix2datetime($unix_millis / 1000);","category":"page"},{"location":"#Result-8","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"The Timestamp64 type is 3.3 times faster at creating a timestamp from a UNIX timestamp in milliseconds compared to Julia's built-in DateTime type! This is partly due to the additional division operation required for the DateTime type.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime Timestamp64($unix_millis * 1_000_000);\n  1.378 ns (0 allocations: 0 bytes)\n\njulia> @btime unix2datetime($unix_millis / 1000);\n  4.507 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#Create-object-from-UNIX-timestamp-in-seconds","page":"Timestamps64.jl","title":"Create object from UNIX timestamp in seconds","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using BenchmarkTools\nusing Timestamps64\nusing Dates\n\nunix_secs = 1609459201; # 2021-01-01T00:00:01.000000000\n\n@btime Timestamp64($unix_secs * 1_000_000_000);\n@btime unix2datetime($unix_secs);","category":"page"},{"location":"#Result-9","page":"Timestamps64.jl","title":"Result","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Almost identical performance for both Timestamp64 and DateTime types.","category":"page"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"julia> @btime Timestamp64($unix_secs * 1_000_000_000);\n  1.539 ns (0 allocations: 0 bytes)\n\njulia> @btime unix2datetime($unix_secs);\n  1.570 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#Bug-reports-and-feature-requests","page":"Timestamps64.jl","title":"Bug reports and feature requests","text":"","category":"section"},{"location":"","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Please report any issues via the GitHub issue tracker.","category":"page"}]
}
